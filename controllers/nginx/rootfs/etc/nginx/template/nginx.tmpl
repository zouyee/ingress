{{ $cfg := .Cfg }}
{{ $IsIPV6Enabled := .IsIPV6Enabled }}
{{ $healthzURI := .HealthzURI }}
{{ $backends := .Backends }}
{{ $proxyHeaders := .ProxySetHeaders }}
daemon off;

worker_processes {{ $cfg.WorkerProcesses }};
pid /run/nginx.pid;
worker_rlimit_nofile {{ .MaxOpenFiles }};


events {
    multi_accept        on;
    worker_connections  {{ $cfg.MaxWorkerConnections }};
    use                 epoll;
}

http {

    # lua section to return proper error codes when custom pages are used
    lua_package_path '$prefix/conf/?.lua;.?.lua;/etc/nginx/lua/?.lua;/etc/nginx/lua/vendor/lua-resty-http/lib/?.lua;';
    init_by_lua '
        ngx.log(ngx.NOTICE, "Use auth module.")
        auth = require "auth"
    ';

    sendfile            on;
    aio                 threads;
    tcp_nopush          on;
    tcp_nodelay         on;
    log_subrequest      on;
    reset_timedout_connection on;
    keepalive_timeout 75s;

    client_header_buffer_size       1k;
    large_client_header_buffers     4 8k;

    http2_max_field_size            4k;
    http2_max_header_size           16k;

    types_hash_max_size             2048;
    server_names_hash_max_size      4;
    server_names_hash_bucket_size   32;
    map_hash_bucket_size            64;

    

    include /etc/nginx/mime.types;
    default_type text/html;

    gzip on;
    gzip_comp_level 5;
    gzip_http_version 1.1;
    gzip_min_length 256;
    gzip_types {{ $cfg.GzipTypes }};
    gzip_proxied any;


    server_tokens on;

    log_format upstreaminfo '{{ buildLogFormatUpstream $cfg }}';




    access_log /var/log/nginx/access.log upstreaminfo if=$loggable;
    error_log  /var/log/nginx/error.log notice;



    # In case of errors try the next upstream server before returning an error
    proxy_next_upstream                     error timeout invalid_header http_502 http_503 http_504;

    proxy_ssl_session_reuse on;

    {{range $name, $upstream := $backends}}
    upstream {{$upstream.Name}} {
        least_conn;

        {{ range $server := $upstream.Endpoints }}server {{ $server.Address }}:{{ $server.Port }} max_fails=0 fail_timeout=0;
        {{ end }}
    }
    {{ end }}



    server {
        server_name locahost;
        listen 80 default_server reuseport;
        listen 443 default_server reuseport ssl http2;
        root /opt/k8s;

        lua_need_request_body on;
        set $token "";
        set $cluster "";
        set $namespace "";
        set $name "";
        if ( $http_cookie ~* "username=([A-Za-z0-9- ]*)" ){
             set $token $1;
        }
        if ( $http_cookie ~* "namespace=([A-Za-z0-9- ]*)" ){
             set $namespace $1;
        }
        if ( $http_cookie ~* "cluster=([A-Za-z0-9- ]*)"){
             set $cluster $1;
        }
        rewrite_by_lua '
            auth = require("auth")
            ngx.var.name = auth.get_name()
        ';



        # auth location
        location ~ ^/apis/cmss.com/v1/(login|verify|authchk) {
            proxy_set_header Host $http_host;
            proxy_pass http://10.142.21.152:32045/apis/cmss.com/v1/$1$is_args$args;
        }
        location ~ ^/apis/cmss.com/v1/authority/user/(?<userid>.*)/conditions {
            proxy_set_header Host $http_host;
            proxy_pass http://10.142.21.152:32045/apis/cmss.com/v1/authority/user/$userid/conditions$is_args$args;
        }

        location /apis/cmss.com/v1/ {
            access_by_lua 'auth.validate_token_and_authority()';
            proxy_set_header Host $http_host;
            proxy_pass http://10.142.21.152:32045/apis/cmss.com/v1/;
        }

        location /image/ {
            proxy_set_header Host $http_host;
            proxy_pass http://{{ $server.Image.Address}}/;
        }



        {{ range $location := $server.Locations }}


        location /{{ $location.Name }}/port9090/api/v1/ {
            proxy_set_header Host $http_host;
            proxy_pass http://{{ $location.Monitor.Address }}:{{ $location.Monitor.Port }}/api/v1/;
        }

        location /{{ $location.Name }}/conductor/api/v1/ {
            access_by_lua 'auth.validate_token_and_authority()';
            proxy_set_header Host $http_host;
            proxy_pass http://{{ $location.Cluster.Address }}:{{ $location.Cluster.Port }}/api/v1/;
        }

        location /{{ $location.Name }}/resource/api/v1/ {
            access_by_lua 'auth.validate_token_and_authority()';
            proxy_set_header Host $http_host;
            proxy_pass http://{{ $location.Resource.Address }}:{{ $location.Resource.Port }}/api/v1/;
        }

        location /{{ $location.Name }}/logmanage/ {
            access_by_lua 'auth.validate_token_and_authority()';
            proxy_set_header Host $http_host;
            proxy_pass http://{{ $location.Log.Address }}:{{ $location.Log.Port }}/;
        }

        location /{{ $location.name }}/alert/ {
            proxy_set_header Host $http_host;
            proxy_pass http://{{ $location.Alert.Address }}:{{ $location.Alert.Port }}/;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }


        {{ end }}


        # health checks in cloud providers require the use of port 80
        location {{ $healthzURI }} {
            access_log off;
            return 200;
        }

        # this is required to avoid error if nginx is being monitored
        # with an external software (like sysdig)
        location /nginx_status {
            allow 127.0.0.1;
            deny all;

            access_log off;
            stub_status on;
        }



    }

    {{ end }}

    # default server, used for NGINX healthcheck and access to nginx stats
    server {
        # Use the port 18080 (random value just to avoid known ports) as default port for nginx.
        # Changing this value requires a change in:
        # https://github.com/kubernetes/contrib/blob/master/ingress/controllers/nginx/nginx/command.go#L104
        listen 18080 default_server reuseport backlog=511;

        location {{ $healthzURI }} {
            access_log off;
            return 200;
        }

        location /nginx_status {
            set $proxy_upstream_name "internal";

            vhost_traffic_status_display;
            vhost_traffic_status_display_format html;

        }

        # this location is used to extract nginx metrics
        # using prometheus.
        # TODO: enable extraction for vts module.
        location /internal_nginx_status {
            set $proxy_upstream_name "internal";

            allow 127.0.0.1;

            deny all;

            access_log off;
            stub_status on;
        }

    }

}
